#!/usr/bin/env ruby

VERSION_S = 'nropster 1.0: Download shows from TiVo and encode to DV'

$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..'))
$:.unshift File.expand_path(File.join(File.dirname(__FILE__), '..', 'httpclient-2.1.2', 'lib'))

require 'rubygems'
require 'ktghttpclient'
require 'nokogiri'
require 'lll'

require 'progressbar'

$log_file = File.open(File.expand_path(File.join(File.dirname(__FILE__), 'log')), 'a')
at_exit {$log_file.close}

def log string_or_option, string = nil
  if string_or_option.kind_of? String
    string = string_or_option
    do_puts = false
  else
    do_puts = string_or_option
  end
  file = $log_file
  if file != $stdout && do_puts
    puts string
  end
  file.puts Time.now.strftime('%m-%d-%y %H:%M ') + string
  file.flush
end

class Nropster
  def initialize(download_now_playing)
    @shows = TiVo.new.shows(download_now_playing).select {|show| show.keep? }
  end

  def show_shows
    @shows.each {|show| puts show.to_s }
  end

  def run
    log true, 'Shows to keep:'
    @shows.each {|show| log true, show.to_s}
    shows = @shows.select {|show| should_download? show}
    log true, 'Shows to download:'
    shows.each {|show| log true, show.to_s}
    jobs = shows.map {|show| Job.new(show, :to_download)}
    Thread.new {DownloadWorker.new(jobs).perform}
    Thread.new {EncodeWorker.new(jobs).perform}
    Thread.list.each {|thread| thread.join unless thread == Thread.main}
  end

  private
  def should_download? show
#    show.full_title =~ /GoodFellas|Sixteen/
    show.full_title =~ /Kelly Takes|Larry/
  end

end

class Job
  attr_reader :show
  attr_accessor :state, :input_filename, :output_filename

  def initialize show, state
    @show = show
    @state = state
  end
end

class DownloadWorker
  def initialize jobs
    @jobs = jobs
    @output_dir = "/Users/mwilden/Nrop/nropster"
  end

  def perform
    begin
      anything_to_be_done = false
      for job in @jobs
        if job.state == :to_download
          anything_to_be_done = true
          download job
        end
      end
      sleep(5)
    end while anything_to_be_done
  end

  def download job
    job.output_filename = "#{@output_dir}/#{job.show.downloaded_filename}"
    log job.output_filename
    progress_bar = nil
    log true, "Downloading #{job.show.full_title} (#{job.show.size_s})"
    IO.popen("tivodecode -o '#{job.output_filename}' -", 'wb') do |tivodecode|
      progress_bar = Console::ProgressBar.new(job.show.full_title, job.show.size)
      job.state = :downloading
      job.show.download do |chunk|
        tivodecode << chunk
        progress_bar.inc(chunk.length)
      end
      job.state = :downloaded
      progress_bar.finish
      log true, "Finished downloading #{job.show.full_title} (#{Console::ProgressBar.convert_bytes(job.show.size).strip})"
    end
  rescue Exception => err
    log true, "Error downloading #{job.show.full_title}: #{err.to_s}"
    job.state = :to_download
    File.delete job.output_filename
  end

end

class EncodeWorker
  def initialize jobs
    @jobs = jobs
    @output_dir = "/Users/mwilden/Nrop/nropster"
  end

  def perform
    begin
      anything_to_be_done = false
      for job in @jobs
        if job.state != :encoded
          anything_to_be_done = true
        end

        if job.state == :downloaded
          encode job
        end
      end
      sleep(5)
    end while anything_to_be_done
  end

  def encode job
    input_filename = job.output_filename
    job.output_filename = "#{@output_dir}/#{job.show.encoded_filename}"
    log true, "Encoding #{input_filename} -> #{job.output_filename}"
    job.state = :encoding
    `/Applications/kmttg/ffmpeg/ffmpeg -y -an -i '#{input_filename}' -threads 2 -croptop 4 -target ntsc-dv '#{job.output_filename}'`
    File.delete input_filename
    job.state = :encoded
    log true, "Finished downloading #{job.show.full_title} (#{Console::ProgressBar.convert_bytes(job.show.size).strip})"
  end

end

class TiVo
  def initialize
    @shows_cache_filename = File.expand_path(File.join(File.dirname(__FILE__), 'shows.xml'))
  end

  def shows(reload = false)
    download_shows if reload
    load_shows
  end

  def download_show show, &block
    Downloader.new(show.url).download &block
  end

  private
  def download_shows
    log true, "Downloading shows..."
    downloader = Downloader.new('https://10.0.1.7/TiVoConnect?Command=QueryContainer&Container=/NowPlaying&Recurse=Yes')
    downloader.download_to_file(@shows_cache_filename)
  end

  def load_shows
    shows = []
    document = Nokogiri::XML(File.read(@shows_cache_filename))
    document.css('Item').each do |item|
      item_details = item.css('Details')
      if item_details.css('ContentType').text =~ /raw-tts/
        shows << Show.new(self, item)
      end
    end
    shows
  end

end

class Show
  attr_reader :size, :url, :title, :episode_title, :time_captured, :duration

  def initialize tivo, item
    @tivo = tivo
    @keep = item.css('Links CustomIcon Url').text =~ /save-until-i-delete-recording/
    @title = item.css('Details Title').text
    @size = item.css('Details SourceSize').text.to_i
    @episode_title = item.css('Details EpisodeTitle').text
    @url = item.css('Links Content Url').text
    @time_captured = Time.at(item.css('Details CaptureDate').text.to_i(16) + 2)
    @duration = item.css('Details Duration').text.to_i / 1000
  end

  def keep?
    @keep
  end

  def full_title
    return @title if @episode_title.empty?
    @title + ' - ' + @episode_title
  end

  def time_captured_s
    @time_captured.strftime('%m-%d %H:%M')
  end

  def duration_s
    minutes = (@duration / 60) % 60
    minutes += 1 if @duration % 60 != 0
    hours = @duration / 3600
    sprintf("%d:%02d", hours, minutes)
  end

  def download &block
    @tivo.download_show self, &block
  end

  def downloaded_filename
    filename_root + '.mpg'
  end

  def encoded_filename
    filename_root + '.dv'
  end

  def to_s
    "#{time_captured_s} #{duration_s} #{full_title} (#{size_s})"
  end

  def size_s
    Console::ProgressBar.convert_bytes(size).strip
  end

  private
  def filename_root
    full_title + ' ' + time_captured_s
  end
end

class Downloader
  def initialize(url)
    @url = url
    @client = HTTPClient.new
    @client.ssl_config.verify_mode = OpenSSL::SSL::VERIFY_NONE
    @client.set_auth(@url, 'tivo', 8185711423)
  end

  def download
    # We ignore the first chunk to work around a bug in
    # http client where we see the "Auth required" digest-auth
    # header.
    first_chunk = true
    get_content do |chunk|
      if first_chunk
        first_chunk = false
        next
      end
      yield chunk
    end
  end

  def download_to_file filename
    File.open(filename, 'w') {|f| f.write get_content}
  end

  private
  def get_content &block
    @client.get_content(@url, &block)
  end

end

log "\n"
log "Program started"

require 'optparse'
options = {}
optparse = OptionParser.new do |opts|
  opts.banner = "Usage nropster [options]"
  options[:download_now_playing] = true
  opts.on('-d', '--[no-]download-now-playing', "(default) Download Now Playing list from TiVo and save for when --no-download-now-playing options is used. ") do
    options[:download_now_playing] = false
  end
  options[:show_now_playing] = false
  opts.on('-s', '--show-now-playing', 'Show Now Playing list and exit') do
    options[:show_now_playing] = true
  end
  opts.on('-v', '--version', 'Show version') do
    log true, VERSION_S
    exit 1
  end
end

begin
  optparse.parse!
rescue OptionParser::InvalidOption => ex
  log true, ex.message
  puts optparse
  exit 1
end
log "Options:"
log "download-now-playing = #{options[:download_now_playing]}"
log "show-now-playing = #{options[:show_now_playing]}"

nropster = Nropster.new(options[:download_now_playing])

if options[:show_now_playing]
  nropster.show_shows
else
  nropster.run
end
